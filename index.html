<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>neals.</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            text-transform: lowercase;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            pointer-events: auto;
            text-align: center;
            background: rgba(5, 5, 5, 0.95);
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            max-width: 90%;
            width: 480px;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .active { display: block; }

        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; color: #3b82f6; text-shadow: 0 0 10px #3b82f6; }
        h2 { font-size: 1.5rem; margin-bottom: 1rem; color: #ef4444; }
        p { margin-bottom: 1.5rem; color: #aaa; line-height: 1.4; }

        button {
            background: transparent;
            border: 1px solid #555;
            color: #fff;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
            border-radius: 4px;
            text-transform: lowercase;
        }

        button:hover { border-color: #fff; background: rgba(255, 255, 255, 0.1); }
        button.primary { border-color: #3b82f6; color: #3b82f6; }

        .upgrade-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
        .upgrade-card { border: 1px solid #333; padding: 15px; cursor: pointer; border-radius: 6px; text-align: left; transition: transform 0.1s; }
        .upgrade-card:hover { border-color: #777; transform: translateX(5px); }

        .type-atk { border-left: 4px solid #ec4899; }
        .type-rng { border-left: 4px solid #eab308; }
        .type-def { border-left: 4px solid #22c55e; }
        .type-ethereal { border-left: 4px solid #a855f7; box-shadow: inset 0 0 10px rgba(168, 85, 247, 0.2); }

        .upgrade-name { font-weight: bold; font-size: 1rem; display: block; }
        .upgrade-category { font-size: 0.7rem; opacity: 0.6; text-transform: uppercase; letter-spacing: 1px; }
        .upgrade-effect { color: #ccc; font-size: 0.85rem; display: block; margin-top: 4px;}
        .upgrade-downside { color: #ef4444; font-size: 0.8rem; font-style: italic; margin-top: 4px;}

        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            pointer-events: none;
            display: none;
            z-index: 5;
        }
        
        .stat-row { margin-bottom: 5px; font-size: 0.9rem; text-shadow: 0 0 3px black; }

        #xpBarContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background: #111;
            z-index: 20;
            display: none;
        }

        #xpBar {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            box-shadow: 0 0 10px #3b82f6;
            transition: width 0.3s;
        }

        #timerOverlay {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #a855f7;
            font-size: 1.5rem;
            font-weight: bold;
            display: none;
            text-shadow: 0 0 10px #a855f7;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="timerOverlay">final stand: <span id="standTimer">120</span>s</div>

    <div id="hud">
        <div class="stat-row" style="color: #ef4444">hp: <span id="hpVal">100</span>/<span id="maxHpVal">100</span></div>
        <div class="stat-row" style="color: #eab308">lvl: <span id="lvlVal">1</span>/30</div>
        <div class="stat-row" style="color: #3b82f6">wave: <span id="waveVal">1</span></div>
    </div>

    <div id="uiLayer">
        <div id="deviceScreen" class="screen active">
            <h1>neals.</h1>
            <p>choose control method</p>
            <button onclick="Game.setDevice('mobile')">touch</button>
            <button onclick="Game.setDevice('pc')">keyboard/mouse</button>
        </div>

        <div id="classScreen" class="screen">
            <h2>select soul</h2>
            <div class="upgrade-grid" id="classOptions">
                <div class="upgrade-card type-atk" onclick="Game.startGame('ravager')">
                    <span class="upgrade-category">atk (ravager)</span>
                    <span class="upgrade-name">lethal strikes</span>
                    <span class="upgrade-effect">massive damage, but fragile body.</span>
                </div>
                <div class="upgrade-card type-rng" onclick="Game.startGame('heavenly')">
                    <span class="upgrade-category">rng (heavenly)</span>
                    <span class="upgrade-name">divine speed</span>
                    <span class="upgrade-effect">constant regeneration, +12.5% speed.</span>
                </div>
                <div class="upgrade-card type-def" onclick="Game.startGame('demonic')">
                    <span class="upgrade-category">def (demonic)</span>
                    <span class="upgrade-name">plated armor</span>
                    <span class="upgrade-effect">bulky armor and high base survival.</span>
                </div>
            </div>
        </div>

        <div id="upgradeScreen" class="screen">
            <h2 id="upgradeTitle" style="color: #22c55e">altar of neal</h2>
            <p id="upgradeSubtitle">choose your mutation</p>
            <div class="upgrade-grid" id="upgradeOptions"></div>
        </div>

        <div id="gameOverScreen" class="screen">
            <h2 id="endStatus" style="color: #ef4444">exhausted.</h2>
            <p>reached wave <span id="finalWave">0</span> at level <span id="finalLvl">0</span></p>
            <button class="primary" onclick="location.reload()">reincarnate</button>
        </div>
    </div>

<script>
const CONFIG = {
    basePlayerSpeed: 3.2,
    baseEnemySpeed: 1.6,
    waveDuration: 400, // Reduced from 600 to make it faster to reach bosses
    maxLevel: 30,
    colors: {
        player: '#3b82f6',
        enemy: '#ef4444',
        altar: '#22c55e',
        ethereal: '#a855f7',
        bullet: '#fff',
        xp: '#eab308',
        rng: '#eab308',
        boss: '#a855f7',
        minion: '#60a5fa',
        mirror: '#ffffff'
    }
};

const UPGRADES_DB = {
    atk: [
        { name: 'frostbite', id: 'frostbite', desc: 'bullets slow by 15%. stacking 3 freezes enemy.', downside: '-5% bullet speed', apply: (p) => { p.frost = (p.frost || 0) + 1; p.bulletSpeed *= 0.95; } },
        { name: 'orbital rammers', id: 'minions', desc: 'summon a small rammer that attacks enemies', downside: '-10% player damage', apply: (p) => { p.minions.push(new Minion(p.x, p.y)); p.damage *= 0.9; } },
        { name: 'volatile core', id: 'explode', desc: 'enemies explode on death (15% chance)', downside: '-10% defense', apply: (p) => { p.onKillEffects.push('explode'); p.defense -= 2; } }
    ],
    rng: [
        { name: 'adrenaline surge', id: 'adrenaline', desc: '70% chance on kill: +70% fire rate for 3s', downside: '-10% movement speed', apply: (p) => { p.onKillEffects.push('adrenaline'); p.speed *= 0.9; } },
        { name: 'risky reload', id: 'risky', desc: '30% chance on kill: -15% damage, +100% multishot', downside: 'fragile fire rate', apply: (p) => { p.onKillEffects.push('risky'); p.multishot += 1; } },
        { name: 'vampiric sigil', id: 'vampire', desc: '10% chance on kill to restore 5% max HP', downside: '-10% regeneration rate', apply: (p) => { p.onKillEffects.push('vampire'); p.regen *= 0.9; } }
    ],
    def: [
        { name: 'spirit katana', id: 'katana', desc: 'automatically deflect/reflect enemy bullets', downside: '-10% max hp', apply: (p) => { p.katana = true; p.maxHp *= 0.9; } },
        { name: 'shield chain', id: 'orbitals', desc: 'rotating orbit of projectiles (stacks 3x)', downside: '-5% movement speed', apply: (p) => { p.orbitals = Math.min(3, (p.orbitals || 0) + 1); p.speed *= 0.95; } },
        { name: 'plated skin', id: 'plate', desc: '+5 flat defense', downside: '-15% fire rate', apply: (p) => { p.defense += 5; p.fireRate *= 1.15; } },
        { name: 'regeneration core', id: 'regen', desc: '+3 hp/sec regen', downside: '-5% speed', apply: (p) => { p.regen += 3; p.speed *= 0.95; } }
    ],
    ethereal: {
        ravager: [
            { id: 'void_reaper', name: 'void reaper', desc: 'kills grant permanent +0.1% damage.', downside: 'hp cannot exceed 40', apply: (p) => { p.onKillEffects.push('void'); p.maxHp = 40; p.hp = Math.min(p.hp, 40); } },
            { id: 'unstable_blink', name: 'unstable blink', desc: 'dash periodically dealing 1000% damage.', downside: 'lose 1 hp per dash', apply: (p) => { p.onKillEffects.push('blink'); } },
            { id: 'soul_harvest', name: 'soul harvest', desc: 'double all soul (xp) gains.', downside: '-30% defense', apply: (p) => { p.xpMult = 2; p.defense -= 10; } }
        ],
        heavenly: [
            { id: 'heavenly_ascension', name: 'heavenly ascension', desc: 'on death: survive 2m with 500% stats.', downside: 'guaranteed death after timer', apply: (p) => { p.hasAscension = true; } },
            { id: 'seraphim_wings', name: 'seraphim wings', desc: '+100% speed, fly over enemies.', downside: '-50% max hp', apply: (p) => { p.speed *= 2; p.maxHp *= 0.5; p.hp = Math.min(p.hp, p.maxHp); } },
            { id: 'divine_halo', name: 'divine halo', desc: 'enemies near you take constant tick damage.', downside: '-20% damage', apply: (p) => { p.halo = true; p.damage *= 0.8; } }
        ],
        demonic: [
            { id: 'infernal_fortress', name: 'infernal fortress', desc: '+50 flat defense, immune to projectiles.', downside: '-50% speed', apply: (p) => { p.defense += 50; p.bulletImmune = true; p.speed *= 0.5; } },
            { id: 'hellfire_trail', name: 'hellfire trail', desc: 'leave fire that deals 50% damage/sec.', downside: 'bullets move slower', apply: (p) => { p.fireTrail = true; p.bulletSpeed *= 0.7; } },
            { id: 'abyssal_hunger', name: 'abyssal hunger', desc: 'damage increases by 1% for every 1% hp missing.', downside: 'no regeneration', apply: (p) => { p.hunger = true; p.regen = 0; } }
        ]
    }
};

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        this.state = 'MENU';
        this.entities = { player: null, enemies: [], bullets: [], enemyBullets: [], particles: [], altars: [], texts: [] };
        this.wave = 1; this.frame = 0;
        this.bossActive = false;
        this.keys = {}; this.mouse = { x: 0, y: 0, down: false };
        this.joystick = { active: false, id: null, originX: 0, originY: 0, curX: 0, curY: 0, vec: {x:0, y:0} };

        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        this.canvas.addEventListener('touchstart', e => this.handleTouchStart(e), {passive: false});
        this.canvas.addEventListener('touchmove', e => this.handleTouchMove(e), {passive: false});
        this.canvas.addEventListener('touchend', e => this.handleTouchEnd(e), {passive: false});

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    setDevice(dev) { this.device = dev; this.showScreen('classScreen'); }

    startGame(archetype) {
        this.state = 'PLAYING';
        this.showScreen('hud');
        document.getElementById('hud').style.display = 'block';
        document.getElementById('xpBarContainer').style.display = 'block';
        this.entities.player = new Player(this.canvas.width/2, this.canvas.height/2, archetype);
        this.wave = 1; this.frame = 0; this.bossActive = false;
        document.getElementById('waveVal').innerText = this.wave;
    }

    showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        if (id !== 'hud') {
            document.getElementById(id).classList.add('active');
            document.getElementById('uiLayer').style.pointerEvents = 'auto';
        } else {
            document.getElementById('uiLayer').style.pointerEvents = 'none';
        }
    }

    handleTouchStart(e) {
        if(this.state !== 'PLAYING') return;
        const t = e.changedTouches[0];
        if (t.clientX < window.innerWidth / 2) {
            this.joystick = { active: true, id: t.identifier, originX: t.clientX, originY: t.clientY, curX: t.clientX, curY: t.clientY, vec: {x:0, y:0} };
        }
    }

    handleTouchMove(e) {
        if(!this.joystick.active) return;
        e.preventDefault();
        for (let t of e.changedTouches) {
            if (t.identifier === this.joystick.id) {
                this.joystick.curX = t.clientX; this.joystick.curY = t.clientY;
                const dx = t.clientX - this.joystick.originX, dy = t.clientY - this.joystick.originY;
                const dist = Math.hypot(dx, dy), maxDist = 50;
                this.joystick.vec = { x: (dx / (dist||1)) * Math.min(dist, maxDist) / maxDist, y: (dy / (dist||1)) * Math.min(dist, maxDist) / maxDist };
            }
        }
    }

    handleTouchEnd(e) { 
        for (let t of e.changedTouches) if (t.identifier === this.joystick.id) this.joystick.active = false; 
    }

    spawnEnemy() {
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -40 : this.canvas.width + 40;
            y = Math.random() * this.canvas.height;
        } else {
            x = Math.random() * this.canvas.width;
            y = Math.random() < 0.5 ? -40 : this.canvas.height + 40;
        }
        const level = Math.floor(this.frame / 1200) + 1;
        this.entities.enemies.push(new Neal(x, y, level));
    }

    spawnBoss() {
        if (this.bossActive) return;
        
        let x = Math.random() < 0.5 ? -100 : this.canvas.width + 100;
        let y = Math.random() * this.canvas.height;
        
        if (this.wave === 30) {
            this.entities.enemies.push(new MirrorBoss(x, y, this.entities.player));
            this.spawnFloatingText(this.canvas.width/2, 50, "mirror of neal", CONFIG.colors.mirror);
        } else {
            this.entities.enemies.push(new Boss(x, y, this.wave));
            this.spawnFloatingText(this.canvas.width/2, 50, "wave " + this.wave + " boss", CONFIG.colors.boss);
        }
        this.bossActive = true;
    }

    spawnAltar(isEthereal = false, x = null, y = null) {
        const p = 80;
        const spawnX = x !== null ? x : p + Math.random() * (this.canvas.width - p*2);
        const spawnY = y !== null ? y : p + Math.random() * (this.canvas.height - p*2);
        
        this.entities.altars.push({ 
            x: spawnX, 
            y: spawnY, 
            r: isEthereal ? 18 : 12,
            isEthereal: isEthereal
        });
    }

    presentUpgrades(isLevelUp = false, isEthereal = false) {
        this.state = 'PAUSED';
        const container = document.getElementById('upgradeOptions');
        container.innerHTML = '';
        
        const p = this.entities.player;
        const title = isEthereal ? "ethereal evolution" : (isLevelUp ? "soul evolution" : "altar activated");
        document.getElementById('upgradeTitle').innerText = title;
        document.getElementById('upgradeTitle').style.color = isEthereal ? CONFIG.colors.ethereal : (isLevelUp ? CONFIG.colors.xp : CONFIG.colors.altar);
        
        if (isEthereal) {
            const archetypeList = UPGRADES_DB.ethereal[p.archetype].filter(u => !p.chosenUpgrades.has(u.id));
            archetypeList.forEach((u) => {
                const el = document.createElement('div');
                el.className = `upgrade-card type-ethereal`;
                el.innerHTML = `
                    <span class="upgrade-category">ethereal evolution</span>
                    <span class="upgrade-name">${u.name}</span>
                    <span class="upgrade-effect">${u.desc}</span>
                    <div class="upgrade-downside">${u.downside}</div>
                `;
                el.onclick = () => { 
                    u.apply(p); 
                    p.chosenUpgrades.add(u.id);
                    this.resumeGame(true); 
                };
                container.appendChild(el);
            });
            if (archetypeList.length === 0) this.resumeGame(true);
        } else {
            const categories = ['atk', 'rng', 'def'];
            categories.forEach(cat => {
                const list = UPGRADES_DB[cat];
                const u = list[Math.floor(Math.random() * list.length)];
                const el = document.createElement('div');
                el.className = `upgrade-card type-${cat}`;
                el.innerHTML = `
                    <span class="upgrade-category">${cat}</span>
                    <span class="upgrade-name">${u.name}</span>
                    <span class="upgrade-effect">${u.desc}</span>
                    <div class="upgrade-downside">${u.downside}</div>
                `;
                el.onclick = () => { u.apply(p); this.resumeGame(!isLevelUp); };
                container.appendChild(el);
            });
        }
        this.showScreen('upgradeScreen');
    }

    resumeGame(fromAltar = true) {
        if (fromAltar) {
            const p = this.entities.player;
            let idx = -1, minD = Infinity;
            this.entities.altars.forEach((a, i) => { const d = Math.hypot(p.x - a.x, p.y - a.y); if(d < minD) { minD = d; idx = i; } });
            if(idx !== -1) this.entities.altars.splice(idx, 1);
        }
        this.state = 'PLAYING'; this.showScreen('hud');
    }

    spawnFloatingText(x, y, text, color) { this.entities.texts.push({x, y, text, color, life: 1, dy: -0.8}); }

    update() {
        if (this.state !== 'PLAYING') return;
        this.frame++;
        const p = this.entities.player;

        // Enemy spawn frequency
        if (this.frame % Math.max(15, 60 - this.wave*2) === 0) this.spawnEnemy();
        
        // Wave management
        if (this.frame % CONFIG.waveDuration === 0) {
            if (this.wave < 30) {
                this.wave++;
                document.getElementById('waveVal').innerText = this.wave;
                
                // Trigger boss exactly on these waves
                if (this.wave === 10 || this.wave === 20 || this.wave === 30) {
                    this.spawnBoss();
                } else if (!this.bossActive) {
                    // Regular wave: spawn altar
                    this.spawnAltar(false);
                }
            } else if (this.wave === 30 && !this.bossActive && !this.entities.enemies.some(e => e.isBoss)) {
                // If boss was killed but we are still at 30, it's endgame
            }
        }

        p.update(this);

        for (let i = this.entities.bullets.length - 1; i >= 0; i--) {
            const b = this.entities.bullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            if (b.life <= 0) this.entities.bullets.splice(i, 1);
        }

        for (let i = this.entities.enemyBullets.length - 1; i >= 0; i--) {
            const b = this.entities.enemyBullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            if (p.katana && Math.hypot(p.x - b.x, p.y - b.y) < 55) {
                b.vx *= -1.5; b.vy *= -1.5; b.damage *= 1.5;
                this.entities.bullets.push(b);
                this.entities.enemyBullets.splice(i, 1);
                continue;
            }
            if (Math.hypot(p.x - b.x, p.y - b.y) < p.r + b.r) { 
                if (!p.bulletImmune) p.takeDamage(b.damage); 
                this.entities.enemyBullets.splice(i, 1); 
            }
            else if (b.life <= 0) this.entities.enemyBullets.splice(i, 1);
        }

        p.minions.forEach(m => m.update(this, p));

        for (let i = this.entities.enemies.length - 1; i >= 0; i--) {
            const e = this.entities.enemies[i];
            e.update(this, p);

            if (p.halo && Math.hypot(p.x - e.x, p.y - e.y) < 120) e.hp -= 0.5;
            
            for (let j = this.entities.bullets.length - 1; j >= 0; j--) {
                const b = this.entities.bullets[j];
                if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
                    e.takeDamage(b.damage, this);
                    if(p.frost) {
                        e.frostStacks = (e.frostStacks || 0) + 1;
                        if(e.frostStacks >= 3) { e.frozen = 60; e.frostStacks = 0; }
                        else { e.speed *= (1 - (0.05 * p.frost)); }
                    }
                    this.entities.bullets.splice(j, 1);
                    break;
                }
            }

            if (p.orbitals) {
                const angle = this.frame * 0.05;
                for (let k = 0; k < p.orbitals; k++) {
                    const ox = p.x + Math.cos(angle + (k * Math.PI * 2 / 3)) * 65;
                    const oy = p.y + Math.sin(angle + (k * Math.PI * 2 / 3)) * 65;
                    if (Math.hypot(e.x - ox, e.y - oy) < e.r + 5) e.takeDamage(2, this);
                }
            }

            if (Math.hypot(e.x - p.x, e.y - p.y) < e.r + p.r) p.takeDamage(e.damage);

            if (e.hp <= 0) {
                const killX = e.x;
                const killY = e.y;
                if (e.isBoss) {
                    this.bossActive = false;
                    p.gainXp(500 * (this.wave/10), this, killX, killY);
                    // Guaranteed Ethereal Altar on boss kill
                    this.spawnAltar(true, killX, killY);
                    
                    if (this.wave === 30) {
                        setTimeout(() => {
                            document.getElementById('endStatus').innerText = "victorious.";
                            document.getElementById('endStatus').style.color = CONFIG.colors.altar;
                            this.gameOver();
                        }, 2500);
                    }
                } else {
                    p.gainXp(15 * e.level, this, killX, killY);
                }
                this.entities.enemies.splice(i, 1);
            }
        }

        for (const a of this.entities.altars) if (Math.hypot(p.x - a.x, p.y - a.y) < p.r + a.r) this.presentUpgrades(false, a.isEthereal);

        this.entities.particles = this.entities.particles.filter(pt => (pt.life -= 0.04) > 0);
        this.entities.particles.forEach(pt => { pt.x += pt.vx; pt.y += pt.vy; });
        this.entities.texts = this.entities.texts.filter(t => (t.life -= 0.02) > 0);
        this.entities.texts.forEach(t => t.y += t.dy);
        
        document.getElementById('hpVal').innerText = Math.ceil(p.hp);
        document.getElementById('maxHpVal').innerText = Math.ceil(p.maxHp);
        document.getElementById('lvlVal').innerText = p.level;
    }

    draw() {
        this.ctx.fillStyle = '#050505';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.state === 'MENU') return;

        this.ctx.shadowBlur = 10;
        for (const a of this.entities.altars) {
            const col = a.isEthereal ? CONFIG.colors.ethereal : CONFIG.colors.altar;
            this.ctx.fillStyle = col; this.ctx.shadowColor = col;
            this.ctx.beginPath(); this.ctx.arc(a.x, a.y, a.r + Math.sin(this.frame/8)*2, 0, Math.PI*2); this.ctx.fill();
        }

        const p = this.entities.player;
        if(p) {
            this.ctx.shadowColor = p.finalStand ? CONFIG.colors.ethereal : CONFIG.colors.player; 
            this.ctx.fillStyle = p.finalStand ? CONFIG.colors.ethereal : CONFIG.colors.player;
            this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); this.ctx.fill();
            
            if (p.halo) {
                this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 120, 0, Math.PI*2);
                this.ctx.strokeStyle = 'rgba(168, 85, 247, 0.2)'; this.ctx.stroke();
            }

            if (p.katana) {
                this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 55, 0, Math.PI*2);
                this.ctx.strokeStyle = 'rgba(255,255,255,0.15)'; this.ctx.stroke();
            }
            if (p.orbitals) {
                const angle = this.frame * 0.05; this.ctx.fillStyle = '#fff';
                for (let k = 0; k < p.orbitals; k++) {
                    const ox = p.x + Math.cos(angle + (k * Math.PI * 2 / 3)) * 65;
                    const oy = p.y + Math.sin(angle + (k * Math.PI * 2 / 3)) * 65;
                    this.ctx.beginPath(); this.ctx.arc(ox, oy, 5, 0, Math.PI*2); this.ctx.fill();
                }
            }
        }

        this.ctx.fillStyle = CONFIG.colors.minion;
        p.minions.forEach(m => { this.ctx.beginPath(); this.ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); this.ctx.fill(); });

        for (const e of this.entities.enemies) {
            if (e.isMirror) { this.ctx.shadowColor = CONFIG.colors.mirror; this.ctx.fillStyle = CONFIG.colors.mirror; }
            else if (e.enemyClass === 'brute') { this.ctx.shadowColor = '#f87171'; this.ctx.fillStyle = '#f87171'; }
            else if (e.enemyClass === 'ranger') { this.ctx.shadowColor = '#4ade80'; this.ctx.fillStyle = '#4ade80'; }
            else if (e.enemyClass === 'phantom') { this.ctx.shadowColor = '#22d3ee'; this.ctx.fillStyle = '#22d3ee'; }
            else {
                this.ctx.shadowColor = e.frozen ? '#60a5fa' : (e.isBoss ? CONFIG.colors.boss : CONFIG.colors.enemy);
                this.ctx.fillStyle = e.frozen ? '#60a5fa' : (e.isBoss ? CONFIG.colors.boss : CONFIG.colors.enemy);
            }
            this.ctx.beginPath(); this.ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); this.ctx.fill();
        }

        this.ctx.shadowColor = CONFIG.colors.bullet; this.ctx.fillStyle = CONFIG.colors.bullet;
        for (const b of this.entities.bullets) { this.ctx.beginPath(); this.ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); this.ctx.fill(); }

        this.ctx.shadowColor = '#facc15'; this.ctx.fillStyle = '#facc15';
        for (const b of this.entities.enemyBullets) { this.ctx.beginPath(); this.ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); this.ctx.fill(); }

        this.ctx.shadowBlur = 0;
        for (const t of this.entities.texts) {
            this.ctx.fillStyle = t.color; this.ctx.globalAlpha = t.life;
            this.ctx.fillText(t.text, t.x, t.y);
        }
        this.ctx.globalAlpha = 1;

        if (this.device === 'mobile' && this.joystick.active) {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath(); this.ctx.arc(this.joystick.originX, this.joystick.originY, 40, 0, Math.PI*2); this.ctx.stroke();
            this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
            this.ctx.beginPath(); this.ctx.arc(this.joystick.curX, this.joystick.curY, 15, 0, Math.PI*2); this.ctx.fill();
        }
    }
    loop() { this.update(); this.draw(); requestAnimationFrame(this.loop); }
    gameOver() { this.state = 'GAME_OVER'; document.getElementById('finalWave').innerText = this.wave; document.getElementById('finalLvl').innerText = this.entities.player.level; this.showScreen('gameOverScreen'); }
}

class Player {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.r = 8;
        this.archetype = type;
        this.level = 1; this.xp = 0; this.maxXp = 100; this.xpMult = 1;
        this.hp = 100; this.maxHp = 100; this.speed = CONFIG.basePlayerSpeed;
        this.damage = 10; this.defense = 0;
        this.fireRate = 18; this.fireTimer = 0;
        this.bulletSpeed = 8; this.regen = 0; this.regenFrame = 0;
        this.multishot = 0; this.minions = []; this.onKillEffects = []; this.buffs = { fireRateMult: 1, damageMult: 1 }; this.buffTimers = [];
        this.chosenUpgrades = new Set();
        this.hasAscension = false; this.finalStand = false; this.standTimer = 120;

        if (type === 'demonic') { this.defense = 5; this.damage = 15; this.speed *= 0.8; this.r = 10; }
        else if (type === 'ravager') { this.damage = 25; this.maxHp = 60; this.hp = 60; this.speed *= 1.15; }
        else if (type === 'heavenly') { this.maxHp = 150; this.hp = 150; this.regen = 2; this.speed *= 1.125; }
    }

    update(game) {
        if (this.finalStand) {
            this.standTimer -= 1/60;
            document.getElementById('standTimer').innerText = Math.ceil(this.standTimer);
            if (this.standTimer <= 0) game.gameOver();
        }

        this.buffs.fireRateMult = (this.finalStand ? 5 : 1); 
        this.buffs.damageMult = (this.finalStand ? 5 : 1);

        if (this.hunger) {
            const missing = 1 - (this.hp / this.maxHp);
            this.buffs.damageMult *= (1 + missing);
        }

        this.buffTimers = this.buffTimers.filter(b => {
            if (b.type === 'adrenaline') this.buffs.fireRateMult *= 1.7;
            if (b.type === 'risky') this.buffs.damageMult *= 0.85;
            return --b.life > 0;
        });

        let dx = 0, dy = 0;
        if (game.device === 'pc') {
            if (game.keys['w']) dy = -1; if (game.keys['s']) dy = 1; if (game.keys['a']) dx = -1; if (game.keys['d']) dx = 1;
            if(dx || dy) { const l = Math.hypot(dx, dy); dx/=l; dy/=l; }
        } else { dx = game.joystick.vec.x; dy = game.joystick.vec.y; }

        const moveSpeed = this.speed * (this.finalStand ? 5 : 1);
        this.x += dx * moveSpeed; this.y += dy * moveSpeed;
        this.x = Math.max(this.r, Math.min(game.canvas.width - this.r, this.x));
        this.y = Math.max(this.r, Math.min(game.canvas.height - this.r, this.y));

        if (this.fireTrail && game.frame % 10 === 0) {
            game.entities.particles.push({ x: this.x, y: this.y, life: 2, vx: 0, vy: 0, damage: this.damage * 0.5 });
        }

        if (this.regen > 0 && ++this.regenFrame >= 60) { this.hp = Math.min(this.maxHp, this.hp + this.regen); this.regenFrame = 0; }

        if (--this.fireTimer <= 0) {
            let tx, ty, fire = false;
            if (game.device === 'pc' && game.mouse.down) { tx = game.mouse.x; ty = game.mouse.y; fire = true; }
            else if (game.device === 'mobile' && game.mouse.down) { tx = game.mouse.x; ty = game.mouse.y; fire = true; }
            else {
                let near = null, minD = 500;
                for(let e of game.entities.enemies) { let d = Math.hypot(this.x-e.x, this.y-e.y); if(d < minD) { minD = d; near = e; } }
                if(near) { tx = near.x; ty = near.y; fire = true; }
            }
            if (fire) {
                this.fireTimer = Math.max(2, (this.fireRate / this.buffs.fireRateMult));
                const angle = Math.atan2(ty - this.y, tx - this.x), count = 1 + this.multishot;
                for(let i=0; i<count; i++) {
                    const offset = (i - (count-1)/2) * 0.15;
                    let d = this.damage * this.buffs.damageMult;
                    game.entities.bullets.push({ x: this.x, y: this.y, vx: Math.cos(angle + offset) * this.bulletSpeed, vy: Math.sin(angle + offset) * this.bulletSpeed, damage: d, life: 75, r: 3 });
                }
            }
        }
    }

    takeDamage(amt) {
        if (this.finalStand) return;
        this.hp -= Math.max(1, amt - this.defense);
        if (this.hp <= 0) {
            if (this.hasAscension) {
                this.finalStand = true; this.hasAscension = false; this.hp = this.maxHp;
                document.getElementById('timerOverlay').style.display = 'block';
                Game.spawnFloatingText(this.x, this.y, "HEAVENLY ASCENSION", "#a855f7");
            } else { Game.gameOver(); }
        }
    }

    gainXp(amt, game, x, y) {
        amt *= this.xpMult;
        this.onKillEffects.forEach(effect => {
            if (effect === 'adrenaline' && Math.random() < 0.7) this.buffTimers.push({ type: 'adrenaline', life: 180 });
            if (effect === 'vampire' && Math.random() < 0.1) this.hp = Math.min(this.maxHp, this.hp + this.maxHp * 0.05);
            if (effect === 'void') this.damage *= 1.001;
        });
        game.spawnFloatingText(x, y, `+${Math.floor(amt)}xp`, CONFIG.colors.xp);
        if (this.level >= CONFIG.maxLevel) return;
        this.xp += amt;
        if (this.xp >= this.maxXp) {
            this.level++; this.xp -= this.maxXp; this.maxXp *= 1.25; this.damage *= 1.1; this.maxHp *= 1.05; this.hp = this.maxHp;
            if (this.level % 5 === 0) game.presentUpgrades(true);
            else game.spawnFloatingText(this.x, this.y, "level up!", CONFIG.colors.xp);
        }
        document.getElementById('xpBar').style.width = `${(this.xp/this.maxXp)*100}%`;
    }
}

class Neal {
    constructor(x, y, level) {
        this.x = x; this.y = y; this.level = level; 
        this.r = 7 + level*0.2; 
        this.hp = 20 * level; 
        this.damage = 6 + level;
        this.speed = CONFIG.baseEnemySpeed + Math.random()*0.3; 
        this.isBoss = false; 
        this.frozen = 0;
        this.enemyClass = null;

        if (level > 15 && Math.random() < 0.25) {
            const roll = Math.random();
            if (roll < 0.33) { this.enemyClass = 'brute'; this.hp *= 2.5; this.speed *= 0.6; this.r *= 1.5; } 
            else if (roll < 0.66) { this.enemyClass = 'ranger'; this.hp *= 0.8; this.shootTimer = 120; } 
            else { this.enemyClass = 'phantom'; this.speed *= 1.8; this.hp *= 0.5; }
        }
    }

    update(game, p) {
        if (this.frozen > 0) { this.frozen--; return; }
        const a = Math.atan2(p.y - this.y, p.x - this.x);
        this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed;

        if (this.enemyClass === 'ranger' && --this.shootTimer <= 0) {
            this.shootTimer = 180;
            game.entities.enemyBullets.push({ x: this.x, y: this.y, vx: Math.cos(a) * 4, vy: Math.sin(a) * 4, damage: this.damage, life: 100, r: 4 });
        }
    }
    takeDamage(d, g) {
        this.hp -= d;
        for(let i=0; i<2; i++) g.entities.particles.push({ x: this.x, y: this.y, life: 1, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4 });
    }
}

class Boss extends Neal {
    constructor(x, y, wave) {
        super(x, y, wave);
        this.isBoss = true;
        this.r = 30;
        // Start weak (Wave 10) and grow exponentially (Wave 20)
        const powerScale = Math.pow(1.9, wave/10 - 1); 
        this.hp = 600 * powerScale; 
        this.damage = 10 * (wave/10);
        this.speed = 0.9 + (wave/100);
        this.shotTimer = 0;
    }
    update(game, p) {
        super.update(game, p);
        if (this.frozen > 0) return;
        if (--this.shotTimer <= 0) {
            this.shotTimer = 80;
            const baseAngle = Math.atan2(p.y - this.y, p.x - this.x);
            for(let i = -2; i <= 2; i++) {
                game.entities.enemyBullets.push({ x: this.x, y: this.y, vx: Math.cos(baseAngle + i * 0.3) * 4.5, vy: Math.sin(baseAngle + i * 0.3) * 4.5, damage: this.damage * 0.7, life: 160, r: 5 });
            }
        }
    }
}

class MirrorBoss extends Neal {
    constructor(x, y, player) {
        super(x, y, player.level);
        this.isBoss = true;
        this.isMirror = true;
        this.r = player.r * 1.5;
        this.hp = player.maxHp * 15; // Increased HP to make it a finale fight
        this.damage = player.damage * 0.8;
        this.speed = player.speed * 0.85;
        this.shotTimer = 0;
        this.playerRef = player;
    }
    update(game, p) {
        if (this.frozen > 0) { this.frozen--; return; }
        const dist = Math.hypot(p.x - this.x, p.y - this.y);
        const angle = Math.atan2(p.y - this.y, p.x - this.x);
        
        // Mirror Logic: try to maintain a combat distance similar to player's preferred range
        if (dist > 250) {
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
        } else if (dist < 150) {
            this.x -= Math.cos(angle) * this.speed;
            this.y -= Math.sin(angle) * this.speed;
        } else {
            this.x += Math.cos(angle + 0.8) * this.speed;
            this.y += Math.sin(angle + 0.8) * this.speed;
        }

        if (--this.shotTimer <= 0) {
            this.shotTimer = 20;
            const shootAngle = Math.atan2(p.y - this.y, p.x - this.x);
            game.entities.enemyBullets.push({ x: this.x, y: this.y, vx: Math.cos(shootAngle) * 8, vy: Math.sin(shootAngle) * 8, damage: this.damage, life: 120, r: 4 });
        }
    }
}

class Minion {
    constructor(x, y) { this.x = x; this.y = y; this.r = 4; this.speed = 4.2; this.damage = 6; }
    update(game, p) {
        let near = null, minD = 350;
        for (let e of game.entities.enemies) { let d = Math.hypot(this.x - e.x, this.y - e.y); if (d < minD) { minD = d; near = e; } }
        if (near) {
            const a = Math.atan2(near.y - this.y, near.x - this.x);
            this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed;
            if (minD < this.r + near.r) near.takeDamage(this.damage, game);
        } else {
            const a = Math.atan2(p.y - this.y, p.x - this.x);
            if (Math.hypot(p.x - this.x, p.y - this.y) > 40) { this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed; }
        }
    }
}

const Game = new GameEngine();
</script>
</body>
</html>
