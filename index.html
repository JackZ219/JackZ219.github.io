<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>neals.</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            text-transform: lowercase;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            pointer-events: auto;
            text-align: center;
            background: rgba(5, 5, 5, 0.95);
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            max-width: 90%;
            width: 520px;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .active { display: block; }

        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; color: #3b82f6; text-shadow: 0 0 10px #3b82f6; }
        h2 { font-size: 1.5rem; margin-bottom: 1rem; color: #ef4444; }
        p { margin-bottom: 1.5rem; color: #aaa; line-height: 1.4; }

        button {
            background: transparent;
            border: 1px solid #555;
            color: #fff;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
            border-radius: 4px;
            text-transform: lowercase;
        }

        button:hover { border-color: #fff; background: rgba(255, 255, 255, 0.1); }
        button.primary { border-color: #3b82f6; color: #3b82f6; }

        .upgrade-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
        .upgrade-card { border: 1px solid #333; padding: 15px; cursor: pointer; border-radius: 6px; text-align: left; transition: transform 0.1s; position: relative; overflow: hidden; }
        .upgrade-card:hover { border-color: #777; transform: translateX(5px); }

        .type-atk { border-left: 4px solid #ec4899; }
        .type-rng { border-left: 4px solid #eab308; }
        .type-def { border-left: 4px solid #22c55e; }
        .type-ethereal { border-left: 4px solid #a855f7; box-shadow: inset 0 0 10px rgba(168, 85, 247, 0.2); }

        .upgrade-name { font-weight: bold; font-size: 1rem; display: block; }
        .upgrade-category { font-size: 0.7rem; opacity: 0.6; text-transform: uppercase; letter-spacing: 1px; }
        .upgrade-effect { color: #ccc; font-size: 0.85rem; display: block; margin-top: 4px;}
        .upgrade-level { position: absolute; top: 10px; right: 10px; font-size: 0.6rem; color: #3b82f6; font-weight: bold; }

        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            pointer-events: none;
            display: none;
            z-index: 5;
        }
        
        .stat-row { margin-bottom: 5px; font-size: 0.9rem; text-shadow: 0 0 3px black; }

        #xpBarContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background: #111;
            z-index: 20;
            display: none;
        }

        #xpBar {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            box-shadow: 0 0 10px #3b82f6;
            transition: width 0.3s;
        }

        #timerOverlay {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #a855f7;
            font-size: 1.5rem;
            font-weight: bold;
            display: none;
            text-shadow: 0 0 10px #a855f7;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="xpBarContainer"><div id="xpBar"></div></div>
    <div id="timerOverlay">final stand: <span id="standTimer">120</span>s</div>

    <div id="hud">
        <div class="stat-row" style="color: #ef4444">hp: <span id="hpVal">100</span>/<span id="maxHpVal">100</span></div>
        <div class="stat-row" style="color: #eab308">lvl: <span id="lvlVal">1</span>/30</div>
        <div class="stat-row" style="color: #3b82f6">wave: <span id="waveVal">1</span></div>
        <div id="luckDisplay" class="stat-row" style="color: #eab308;">luck: +<span id="luckVal">0</span>%</div>
    </div>

    <div id="uiLayer">
        <div id="deviceScreen" class="screen active">
            <h1>neals.</h1>
            <p>choose control method</p>
            <button onclick="Game.setDevice('mobile')">touch</button>
            <button onclick="Game.setDevice('pc')">keyboard/mouse</button>
        </div>

        <div id="classScreen" class="screen">
            <h2>select soul</h2>
            <div class="upgrade-grid" id="classOptions">
                <div class="upgrade-card type-atk" onclick="Game.startGame('phantom')">
                    <span class="upgrade-category">phantom</span>
                    <span class="upgrade-name">lethal strikes</span>
                    <span class="upgrade-effect">massive damage, but fragile body. base luck: 0%.</span>
                </div>
                <div class="upgrade-card type-rng" onclick="Game.startGame('angelic')">
                    <span class="upgrade-category">angelic</span>
                    <span class="upgrade-name">divine speed</span>
                    <span class="upgrade-effect">regen, +12.5% speed, +15% fire rate. every kill grants +0.5% luck.</span>
                </div>
                <div class="upgrade-card type-def" onclick="Game.startGame('demonic')">
                    <span class="upgrade-category">demonic</span>
                    <span class="upgrade-name">plated armor</span>
                    <span class="upgrade-effect">bulky armor and high base survival. base luck: -10%.</span>
                </div>
            </div>
        </div>

        <div id="upgradeScreen" class="screen">
            <h2 id="upgradeTitle" style="color: #22c55e">altar of neal</h2>
            <p id="upgradeSubtitle">choose your mutation</p>
            <div class="upgrade-grid" id="upgradeOptions"></div>
        </div>

        <div id="gameOverScreen" class="screen">
            <h2 id="endStatus" style="color: #ef4444">exhausted.</h2>
            <p>reached wave <span id="finalWave">0</span> at level <span id="finalLvl">0</span></p>
            <button class="primary" onclick="location.reload()">reincarnate</button>
        </div>
    </div>

<script>
const CONFIG = {
    basePlayerSpeed: 3.2,
    baseEnemySpeed: 1.6,
    waveDuration: 400,
    maxLevel: 30,
    colors: {
        player: '#3b82f6',
        enemy: '#ef4444',
        altar: '#22c55e',
        ethereal: '#a855f7',
        bullet: '#fff',
        xp: '#eab308',
        rng: '#eab308',
        boss: '#a855f7',
        minion: '#60a5fa',
        mirror: '#ffffff',
        indicator: 'rgba(239, 68, 68, 0.4)'
    }
};

const UPGRADES_DB = {
    atk: [
        { 
            id: 'swift_firing', 
            name: 'swift firing', 
            getDesc: (lv) => lv === 1 ? "faster fire rate, -2 def, -3% dmg." : lv === 2 ? "even faster, -3 def, -6% dmg." : "max rate, -5 def, -10% dmg.",
            apply: (p, lv) => { 
                p.fireRate = Math.max(4, p.fireRate - 4); 
                p.defense -= (lv === 1 ? 2 : (lv === 2 ? 1 : 2));
                p.damage *= 0.97;
            } 
        },
        { 
            id: 'frostbite', 
            name: 'frostbite', 
            getDesc: (lv) => lv === 3 ? "frozen status: enemies stop completely." : `slows enemies. power: ${lv}`,
            apply: (p, lv) => { p.frost = lv; } 
        },
        { 
            id: 'minions', 
            name: 'orbital rammers', 
            getDesc: (lv) => `summons ${lv} orbital rammer${lv>1?'s':''} that orbit you.`,
            apply: (p, lv) => { p.minionCount = lv; } 
        },
        { 
            id: 'static_field', 
            name: 'static field', 
            getDesc: (lv) => `shocks nearby enemies on fire. ${lv * 15}% trigger chance.`,
            apply: (p, lv) => { p.shockChance = lv * 0.15; } 
        }
    ],
    rng: [
        { 
            id: 'adrenaline', 
            name: 'adrenaline', 
            getDesc: (lv) => `kills boost fire rate for ${lv * 2}s. 15% chance.`,
            apply: (p, lv) => { p.adrenalineChance = 0.15; p.adrenalineLv = lv; } 
        },
        { 
            id: 'multishot', 
            name: 'risky reload', 
            getDesc: (lv) => `fire ${lv + 1} bullets per shot. 20% chance.`,
            apply: (p, lv) => { p.multishotChance = 0.20; p.multishot = lv; } 
        },
        { 
            id: 'singularity', 
            name: 'singularity', 
            getDesc: (lv) => `bullets have ${lv * 12}% chance to pull enemies toward impact.`,
            apply: (p, lv) => { p.pullChance = lv * 0.12; } 
        },
        { 
            id: 'chain', 
            name: 'chain lightning', 
            getDesc: (lv) => `bullets jump to ${lv} targets. 40% chance.`,
            apply: (p, lv) => { p.chainChance = 0.40; p.chainCount = lv; } 
        }
    ],
    def: [
        { 
            id: 'katana', 
            name: 'spirit katana', 
            getDesc: (lv) => lv === 1 ? "reflect enemy bullets in a small zone." : lv === 2 ? "wider reflection zone." : "3x damage on reflected bullets.",
            apply: (p, lv) => { 
                p.katana = lv; 
                p.katanaRange = 45 + (lv * 15);
            } 
        },
        { 
            id: 'regen', 
            name: 'regeneration core', 
            getDesc: (lv) => `restores ${lv * 1.5} hp every second.`,
            apply: (p, lv) => { p.regen = lv * 1.5; } 
        },
        { 
            id: 'phase_shift', 
            name: 'phase shift', 
            getDesc: (lv) => `become invincible for ${lv * 0.5}s after taking damage.`,
            apply: (p, lv) => { p.phaseTime = lv * 30; } 
        },
        { 
            id: 'thorns', 
            name: 'barbed skin', 
            getDesc: (lv) => `melee attackers take ${lv * 5} damage.`,
            apply: (p, lv) => { p.thorns = lv * 5; } 
        }
    ],
    ethereal: {
        phantom: [
            { id: 'void_reaper', name: 'void reaper', desc: 'kills grant +0.1% damage. hp capped at 40.', apply: (p) => { p.voidReaper = true; p.maxHp = 40; p.hp = Math.min(p.hp, 40); } },
            { id: 'unstable_blink', name: 'unstable blink', desc: 'auto-dash dealing huge damage at cost of 1hp.', apply: (p) => { p.blink = true; } }
        ],
        angelic: [
            { id: 'angel_ascension', name: 'angelic ascension', desc: 'survive 2m with 500% stats after death.', apply: (p) => { p.hasAscension = true; } },
            { id: 'divine_halo', name: 'divine halo', desc: 'enemies near you take massive ticking damage (10/sec).', apply: (p) => { p.halo = true; } },
            { id: 'fortune_blessing', name: 'blessing of luck', desc: 'double luck triggers. rng upgrades appear 50% more often.', apply: (p) => { p.luckFactor = (p.luckFactor || 1) * 2; p.rngBias = true; } }
        ],
        demonic: [
            { id: 'infernal_fortress', name: 'infernal fortress', desc: '+50 defense, immune to bullets. -50% speed.', apply: (p) => { p.defense += 50; p.bulletImmune = true; p.speed *= 0.5; } },
            { id: 'abyssal_hunger', name: 'abyssal hunger', desc: 'damage scales with missing hp. no regen.', apply: (p) => { p.hunger = true; p.regen = 0; } },
            { id: 'singularity_eth', name: 'dark singularity', desc: 'demonic bullets pull souls with 25% extra chance.', apply: (p) => { p.pullChance = (p.pullChance || 0) + 0.25; } }
        ]
    }
};

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        this.state = 'MENU';
        this.entities = { player: null, enemies: [], bullets: [], enemyBullets: [], particles: [], altars: [], texts: [], minions: [] };
        this.spawnIndicators = [];
        this.wave = 1; this.frame = 0;
        this.bossActive = false;
        this.keys = {}; this.mouse = { x: 0, y: 0, down: false };
        this.joystick = { active: false, id: null, originX: 0, originY: 0, curX: 0, curY: 0, vec: {x:0, y:0} };

        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        this.canvas.addEventListener('touchstart', e => this.handleTouchStart(e), {passive: false});
        this.canvas.addEventListener('touchmove', e => this.handleTouchMove(e), {passive: false});
        this.canvas.addEventListener('touchend', e => this.handleTouchEnd(e), {passive: false});

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    setDevice(dev) { this.device = dev; this.showScreen('classScreen'); }

    startGame(archetype) {
        this.state = 'PLAYING';
        this.showScreen('hud');
        document.getElementById('hud').style.display = 'block';
        document.getElementById('xpBarContainer').style.display = 'block';
        this.entities = { player: new Player(this.canvas.width/2, this.canvas.height/2, archetype), enemies: [], bullets: [], enemyBullets: [], particles: [], altars: [], texts: [], minions: [] };
        this.spawnIndicators = [];
        this.wave = 1; this.frame = 0; this.bossActive = false;
        document.getElementById('waveVal').innerText = this.wave;
    }

    showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        if (id !== 'hud') {
            document.getElementById(id).classList.add('active');
            document.getElementById('uiLayer').style.pointerEvents = 'auto';
        } else { document.getElementById('uiLayer').style.pointerEvents = 'none'; }
    }

    handleTouchStart(e) {
        if(this.state !== 'PLAYING') return;
        const t = e.changedTouches[0];
        if (t.clientX < window.innerWidth / 2) {
            this.joystick = { active: true, id: t.identifier, originX: t.clientX, originY: t.clientY, curX: t.clientX, curY: t.clientY, vec: {x:0, y:0} };
        }
    }

    handleTouchMove(e) {
        if(!this.joystick.active) return;
        e.preventDefault();
        for (let t of e.changedTouches) {
            if (t.identifier === this.joystick.id) {
                this.joystick.curX = t.clientX; this.joystick.curY = t.clientY;
                const dx = t.clientX - this.joystick.originX, dy = t.clientY - this.joystick.originY;
                const dist = Math.hypot(dx, dy), maxDist = 50;
                this.joystick.vec = { x: (dx / (dist||1)) * Math.min(dist, maxDist) / maxDist, y: (dy / (dist||1)) * Math.min(dist, maxDist) / maxDist };
            }
        }
    }

    handleTouchEnd(e) { for (let t of e.changedTouches) if (t.identifier === this.joystick.id) this.joystick.active = false; }

    planSpawn(lvOverride = null) {
        let x, y;
        const margin = 20;
        if (Math.random() < 0.5) { x = Math.random() < 0.5 ? margin : this.canvas.width - margin; y = Math.random() * this.canvas.height; }
        else { x = Math.random() * this.canvas.width; y = Math.random() < 0.5 ? margin : this.canvas.height - margin; }
        const lv = lvOverride !== null ? lvOverride : Math.max(1, Math.floor(this.frame / 1200) + 1);
        this.spawnIndicators.push({ x, y, lv, timer: 60 });
    }

    spawnEnemy(x, y, lv) {
        this.entities.enemies.push(new Neal(x, y, lv));
    }

    spawnBoss() {
        if (this.bossActive) return;
        let x = Math.random() < 0.5 ? 100 : this.canvas.width - 100, y = Math.random() * this.canvas.height;
        if (this.wave === 30) this.entities.enemies.push(new MirrorBoss(x, y, this.entities.player));
        else this.entities.enemies.push(new Boss(x, y, this.wave));
        this.bossActive = true;
    }

    spawnAltar(isEthereal = false, x = null, y = null) {
        const spawnX = x !== null ? x : 80 + Math.random() * (this.canvas.width - 160);
        const spawnY = y !== null ? y : 80 + Math.random() * (this.canvas.height - 160);
        this.entities.altars.push({ x: spawnX, y: spawnY, r: isEthereal ? 18 : 12, isEthereal });
    }

    presentUpgrades(isLevelUp = false, isEthereal = false) {
        this.state = 'PAUSED';
        const container = document.getElementById('upgradeOptions');
        container.innerHTML = '';
        const p = this.entities.player;
        
        if (isEthereal) {
            const list = UPGRADES_DB.ethereal[p.archetype].filter(u => !p.etherealUpgrades.has(u.id));
            list.forEach(u => {
                const el = document.createElement('div');
                el.className = 'upgrade-card type-ethereal';
                el.innerHTML = `<span class="upgrade-category">ethereal</span><span class="upgrade-name">${u.name}</span><span class="upgrade-effect">${u.desc}</span>`;
                el.onclick = () => { u.apply(p); p.etherealUpgrades.add(u.id); this.resumeGame(true); };
                container.appendChild(el);
            });
            if (list.length === 0) this.resumeGame(true);
        } else {
            let cats = ['atk', 'rng', 'def'];
            cats.forEach(cat => {
                let pool = UPGRADES_DB[cat].filter(u => (p.upgrades[u.id] || 0) < 3);
                if (pool.length > 0) {
                    const u = pool[Math.floor(Math.random() * pool.length)];
                    const lv = (p.upgrades[u.id] || 0) + 1;
                    const el = document.createElement('div');
                    el.className = `upgrade-card type-${cat}`;
                    el.innerHTML = `<span class="upgrade-level">tier ${lv}</span><span class="upgrade-category">${cat}</span><span class="upgrade-name">${u.name}</span><span class="upgrade-effect">${u.getDesc(lv)}</span>`;
                    el.onclick = () => { 
                        p.upgrades[u.id] = lv; 
                        u.apply(p, lv); 
                        if (u.id === 'minions') {
                            this.entities.minions = [];
                            for(let i=0; i<lv; i++) this.entities.minions.push(new Minion(p, i));
                        }
                        this.resumeGame(!isLevelUp); 
                    };
                    container.appendChild(el);
                }
            });
        }
        this.showScreen('upgradeScreen');
    }

    resumeGame(fromAltar = true) {
        if (fromAltar) {
            const p = this.entities.player;
            let idx = -1, minD = Infinity;
            this.entities.altars.forEach((a, i) => { const d = Math.hypot(p.x-a.x, p.y-a.y); if(d<minD) { minD=d; idx=i; } });
            if(idx !== -1) this.entities.altars.splice(idx, 1);
        }
        this.state = 'PLAYING'; this.showScreen('hud');
    }

    spawnFloatingText(x, y, text, color, life = 1) { 
        this.entities.texts.push({x, y, text, color, life, dy: -0.6, fade: 0.015}); 
    }

    update() {
        if (this.state !== 'PLAYING') return;
        this.frame++;
        const p = this.entities.player;

        const spawnRate = Math.max(15, 60 - this.wave * 1.5);
        if (this.frame % spawnRate === 0) this.planSpawn();
        
        // Minimalist Swarm indicator
        if (this.frame % 1200 === 0 && Math.random() > 0.6) {
            this.spawnFloatingText(this.canvas.width/2 - 50, 100, "swarm incoming", CONFIG.colors.enemy, 2.5);
            for(let i=0; i<10; i++) setTimeout(() => this.planSpawn(), i * 150);
        }

        // Process Spawn Indicators (Circles)
        for (let i = this.spawnIndicators.length - 1; i >= 0; i--) {
            const ind = this.spawnIndicators[i];
            ind.timer--;
            if (ind.timer <= 0) {
                this.spawnEnemy(ind.x, ind.y, ind.lv);
                this.spawnIndicators.splice(i, 1);
            }
        }

        if (this.frame % CONFIG.waveDuration === 0 && this.wave < 30) {
            this.wave++;
            document.getElementById('waveVal').innerText = this.wave;
            if (this.wave % 10 === 0) this.spawnBoss();
            else if (!this.bossActive) this.spawnAltar(false);
        }

        p.update(this);

        // Bullets (Player's)
        for (let i = this.entities.bullets.length - 1; i >= 0; i--) {
            const b = this.entities.bullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            if (b.life <= 0) this.entities.bullets.splice(i, 1);
        }

        // Enemy Bullets
        for (let i = this.entities.enemyBullets.length - 1; i >= 0; i--) {
            const b = this.entities.enemyBullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            
            if (p.katana) {
                const dist = Math.hypot(p.x - b.x, p.y - b.y);
                if (dist < p.katanaRange) {
                    this.entities.particles.push({ x: b.x, y: b.y, vx: 0, vy: 0, life: 0.5, color: '#22c55e' });
                    b.vx *= -1.5; b.vy *= -1.5; 
                    if (p.katana === 3) b.damage *= 3;
                    this.entities.bullets.push(b);
                    this.entities.enemyBullets.splice(i, 1);
                    continue;
                }
            }
            
            if (Math.hypot(p.x - b.x, p.y - b.y) < p.r + b.r) { 
                if (!p.bulletImmune && p.phaseTimer <= 0) p.takeDamage(b.damage); 
                this.entities.enemyBullets.splice(i, 1); 
            } else if (b.life <= 0) this.entities.enemyBullets.splice(i, 1);
        }

        // Enemies
        for (let i = this.entities.enemies.length - 1; i >= 0; i--) {
            const e = this.entities.enemies[i];
            e.update(this, p);
            
            if (p.halo && Math.hypot(p.x - e.x, p.y - e.y) < 120) e.hp -= 0.16;

            for (let j = this.entities.bullets.length - 1; j >= 0; j--) {
                const b = this.entities.bullets[j];
                if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
                    e.takeDamage(b.damage, this);
                    if (p.pullChance && Math.random() < p.pullChance * (1 + p.luck/100)) { 
                        if (Math.hypot(e.x - p.x, e.y - p.y) > 65) {
                            const pullA = Math.atan2(b.y - e.y, b.x - e.x);
                            e.x += Math.cos(pullA) * 20; e.y += Math.sin(pullA) * 20;
                        }
                    }
                    this.entities.bullets.splice(j, 1);
                    break;
                }
            }

            if (Math.hypot(e.x - p.x, e.y - p.y) < e.r + p.r) {
                p.takeDamage(e.damage);
                if (p.thorns) e.takeDamage(p.thorns, this);
            }

            if (e.hp <= 0) {
                const xpGain = e.isBoss ? 1000 : 15;
                p.gainXp(xpGain, this, e.x, e.y);
                // Minimalist +xp indicator
                this.spawnFloatingText(e.x, e.y - 10, `+${xpGain}xp`, CONFIG.colors.xp);
                if (e.isBoss) { this.bossActive = false; this.spawnAltar(true, e.x, e.y); if(this.wave === 30) this.gameOver(true); }
                this.entities.enemies.splice(i, 1);
            }
        }

        this.entities.minions.forEach(m => m.update(this, p));
        for (const a of this.entities.altars) if (Math.hypot(p.x - a.x, p.y - a.y) < p.r + a.r) this.presentUpgrades(false, a.isEthereal);
        this.entities.particles = this.entities.particles.filter(pt => (pt.life -= 0.04) > 0);
        this.entities.texts = this.entities.texts.filter(t => {
            t.y += t.dy;
            return (t.life -= t.fade) > 0;
        });
        
        document.getElementById('hpVal').innerText = Math.ceil(p.hp);
        document.getElementById('maxHpVal').innerText = Math.ceil(p.maxHp);
        document.getElementById('lvlVal').innerText = p.level;
        document.getElementById('luckVal').innerText = p.luck.toFixed(1);
    }

    draw() {
        this.ctx.fillStyle = '#050505';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.state === 'MENU') return;

        // Draw Spawn Indicators (Red circles pulsing)
        for (const ind of this.spawnIndicators) {
            this.ctx.beginPath();
            this.ctx.arc(ind.x, ind.y, 15 * (ind.timer / 60), 0, Math.PI * 2);
            this.ctx.strokeStyle = CONFIG.colors.indicator;
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 10;
        const p = this.entities.player;
        if(p) {
            if (p.katana) {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.katanaRange, 0, Math.PI * 2);
                this.ctx.strokeStyle = `rgba(34, 197, 94, ${0.1 + (Math.sin(this.frame / 10) * 0.05)})`;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            this.ctx.shadowColor = p.finalStand ? CONFIG.colors.ethereal : CONFIG.colors.player; 
            this.ctx.fillStyle = p.finalStand ? CONFIG.colors.ethereal : CONFIG.colors.player;
            if (p.phaseTimer > 0) this.ctx.globalAlpha = 0.5;
            this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); this.ctx.fill();
            this.ctx.globalAlpha = 1;
        }

        for (const a of this.entities.altars) {
            const col = a.isEthereal ? CONFIG.colors.ethereal : CONFIG.colors.altar;
            this.ctx.fillStyle = col; this.ctx.shadowColor = col;
            this.ctx.beginPath(); this.ctx.arc(a.x, a.y, a.r + Math.sin(this.frame/8)*2, 0, Math.PI*2); this.ctx.fill();
        }

        for (const m of this.entities.minions) {
            this.ctx.shadowColor = CONFIG.colors.minion; this.ctx.fillStyle = CONFIG.colors.minion;
            this.ctx.beginPath(); this.ctx.arc(m.x, m.y, 4, 0, Math.PI*2); this.ctx.fill();
        }

        for (const e of this.entities.enemies) {
            this.ctx.shadowColor = e.isBoss ? (e.isMirror ? CONFIG.colors.mirror : CONFIG.colors.boss) : CONFIG.colors.enemy;
            this.ctx.fillStyle = e.isBoss ? (e.isMirror ? CONFIG.colors.mirror : CONFIG.colors.boss) : CONFIG.colors.enemy;
            this.ctx.beginPath(); this.ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); this.ctx.fill();
        }

        this.ctx.shadowColor = CONFIG.colors.bullet; this.ctx.fillStyle = CONFIG.colors.bullet;
        for (const b of this.entities.bullets) { this.ctx.beginPath(); this.ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); this.ctx.fill(); }
        this.ctx.shadowColor = '#facc15'; this.ctx.fillStyle = '#facc15';
        for (const b of this.entities.enemyBullets) { this.ctx.beginPath(); this.ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); this.ctx.fill(); }
        
        this.ctx.shadowBlur = 0;
        for (const t of this.entities.texts) { 
            this.ctx.font = '700 12px "JetBrains Mono"';
            this.ctx.fillStyle = t.color; this.ctx.globalAlpha = Math.min(1, t.life); 
            this.ctx.fillText(t.text, t.x, t.y); 
        }
        this.ctx.globalAlpha = 1;
    }
    loop() { this.update(); this.draw(); requestAnimationFrame(this.loop); }
    gameOver(win = false) { 
        this.state = 'GAME_OVER'; 
        document.getElementById('endStatus').innerText = win ? "victorious." : "exhausted.";
        document.getElementById('finalWave').innerText = this.wave; 
        document.getElementById('finalLvl').innerText = this.entities.player.level; 
        this.showScreen('gameOverScreen'); 
    }
}

class Player {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.r = 8; this.archetype = type;
        this.level = 1; this.xp = 0; this.maxXp = 100;
        this.hp = 100; this.maxHp = 100; this.speed = CONFIG.basePlayerSpeed;
        this.damage = 10; this.defense = 0; this.regen = 0;
        this.fireRate = 18; this.fireTimer = 0; this.multishot = 0;
        this.upgrades = {}; this.etherealUpgrades = new Set();
        this.adrenalineTimer = 0;
        this.phaseTimer = 0; this.phaseTime = 0;
        this.katana = 0; this.katanaRange = 0;
        this.luck = type === 'angelic' ? 0 : (type === 'demonic' ? -10 : 0);
        if (type === 'angelic') { this.regen = 1.0; this.speed *= 1.125; this.fireRate *= 0.85; }
        if (type === 'phantom') { this.damage *= 1.5; this.maxHp = 60; this.hp = 60; }
        if (type === 'demonic') { this.defense = 5; this.maxHp = 150; this.hp = 150; }
    }

    update(game) {
        if (this.finalStand) { this.standTimer -= 1/60; document.getElementById('standTimer').innerText = Math.ceil(this.standTimer); if (this.standTimer <= 0) game.gameOver(); }
        if (this.adrenalineTimer > 0) this.adrenalineTimer--;
        if (this.phaseTimer > 0) this.phaseTimer--;

        let dx = 0, dy = 0;
        if (game.device === 'pc') {
            if (game.keys['w']) dy = -1; if (game.keys['s']) dy = 1; if (game.keys['a']) dx = -1; if (game.keys['d']) dx = 1;
            if(dx || dy) { const l = Math.hypot(dx, dy); dx/=l; dy/=l; }
        } else { dx = game.joystick.vec.x; dy = game.joystick.vec.y; }

        this.x += dx * this.speed * (this.finalStand ? 3 : 1);
        this.y += dy * this.speed * (this.finalStand ? 3 : 1);
        this.x = Math.max(this.r, Math.min(game.canvas.width - this.r, this.x));
        this.y = Math.max(this.r, Math.min(game.canvas.height - this.r, this.y));

        if (this.regen > 0 && game.frame % 60 === 0) this.hp = Math.min(this.maxHp, this.hp + this.regen);

        if (--this.fireTimer <= 0) {
            let tx, ty, fire = false;
            if (game.mouse.down) { tx = game.mouse.x; ty = game.mouse.y; fire = true; }
            else {
                let near = null, minD = 500;
                for(let e of game.entities.enemies) { let d = Math.hypot(this.x-e.x, this.y-e.y); if(d < minD) { minD = d; near = e; } }
                if(near) { tx = near.x; ty = near.y; fire = true; }
            }
            if (fire) {
                // Adrenaline Buff: previous strength (significant reduction, no internal cooldown)
                this.fireTimer = (this.adrenalineTimer > 0) ? Math.floor(this.fireRate * 0.2) : this.fireRate;
                const angle = Math.atan2(ty - this.y, tx - this.x);
                let count = 1;
                if (this.multishot > 0 && Math.random() < (this.multishotChance || 0.2) * (1 + this.luck/100)) count += this.multishot;
                for(let i=0; i < count; i++) {
                    const off = (i - (count-1)/2) * 0.2;
                    game.entities.bullets.push({ x: this.x, y: this.y, vx: Math.cos(angle+off)*8, vy: Math.sin(angle+off)*8, damage: this.damage, life: 75, r: 3 });
                }
            }
        }
    }

    takeDamage(amt) {
        if (this.phaseTimer > 0) return;
        this.hp -= Math.max(1, amt - this.defense);
        if (this.phaseTime > 0) this.phaseTimer = this.phaseTime;
        if (this.hp <= 0) {
            if (this.hasAscension) { this.finalStand = true; this.hasAscension = false; this.hp = this.maxHp; this.standTimer = 120; document.getElementById('timerOverlay').style.display = 'block'; }
            else Game.gameOver();
        }
    }

    gainXp(amt, game, x, y) {
        if (this.voidReaper) this.damage *= 1.001;
        if (this.archetype === 'angelic') this.luck += 0.5;
        // Adrenaline Trigger logic: No cooldown, stacks duration
        if (this.adrenalineChance && Math.random() < this.adrenalineChance * (1 + this.luck/100)) {
            this.adrenalineTimer += (this.adrenalineLv || 1) * 120;
        }
        this.xp += amt;
        if (this.xp >= this.maxXp) {
            this.level++; this.xp = 0; this.maxXp *= 1.2;
            if (this.level % 5 === 0) game.presentUpgrades(true);
        }
        document.getElementById('xpBar').style.width = `${(this.xp/this.maxXp)*100}%`;
    }
}

class Neal {
    constructor(x, y, level) {
        this.x = x; this.y = y; this.level = level; 
        this.r = 7 + level*0.2; this.hp = 20 * level; 
        this.damage = 6 + level; this.speed = CONFIG.baseEnemySpeed + (level * 0.05);
    }
    update(game, p) {
        const a = Math.atan2(p.y - this.y, p.x - this.x);
        this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed;
    }
    takeDamage(d, g) { this.hp -= d; }
}

class Minion {
    constructor(player, index) {
        this.angle = (Math.PI * 2 / 3) * index;
        this.dist = 65;
        this.x = player.x; this.y = player.y;
        this.damage = 5;
    }
    update(game, p) {
        this.angle += 0.04;
        this.x = p.x + Math.cos(this.angle) * this.dist;
        this.y = p.y + Math.sin(this.angle) * this.dist;
        game.entities.enemies.forEach(e => {
            if (Math.hypot(e.x - this.x, e.y - this.y) < e.r + 5) e.takeDamage(this.damage, game);
        });
    }
}

class Boss extends Neal {
    constructor(x, y, wave) {
        super(x, y, wave); 
        this.isBoss = true; 
        this.r = 30; 
        this.hp = 500 * (wave/10);
        this.fireTimer = 60;
        // Buff: Boss is way slower
        this.speed = CONFIG.baseEnemySpeed * 0.4;
    }
    update(game, p) {
        super.update(game, p);
        if (--this.fireTimer <= 0) {
            this.fireTimer = 100;
            const a = Math.atan2(p.y - this.y, p.x - this.x);
            for (let i = 0; i < 3; i++) {
                const spread = (i - 1) * 0.3;
                game.entities.enemyBullets.push({ x: this.x, y: this.y, vx: Math.cos(a + spread) * 5, vy: Math.sin(a + spread) * 5, damage: 15, life: 200, r: 5 });
            }
        }
    }
}

class MirrorBoss extends Neal {
    constructor(x, y, player) {
        super(x, y, player.level);
        this.isBoss = true; this.isMirror = true;
        this.r = player.r * 1.5; this.hp = player.maxHp * 15;
        this.damage = player.damage; 
        // Mirror boss is also slower
        this.speed = player.speed * 0.35;
        this.fireTimer = 0;
    }
    update(game, p) {
        const dist = Math.hypot(p.x - this.x, p.y - this.y);
        const a = Math.atan2(p.y - this.y, p.x - this.x);
        if (dist > 250) { this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed; }
        else if (dist < 180) { this.x -= Math.cos(a) * this.speed; this.y -= Math.sin(a) * this.speed; }
        if (--this.fireTimer <= 0) {
            this.fireTimer = 30;
            game.entities.enemyBullets.push({ x: this.x, y: this.y, vx: Math.cos(a)*7, vy: Math.sin(a)*7, damage: 10, life: 120, r: 5 });
        }
    }
}

const Game = new GameEngine();
</script>
</body>
</html>
